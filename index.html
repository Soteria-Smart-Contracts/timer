<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Tracker</title>
    <style>
        body {
            font-family: 'Arial', 'Helvetica', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            transition: background-color 0.5s ease; /* Phase 5 */
        }
        body.timer-active { /* Phase 5 */
            background-color: #f0f8f0; 
        }

        #sessionTimeDisplay {
            font-size: 1.8rem;
            color: #555555;
            margin-bottom: 10px;
            margin-top: 20px; 
        }

        #totalTimeDisplay {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #333;
        }

        #startStopButton {
            width: 200px; /* Phase 5 */
            height: 200px; /* Phase 5 */
            cursor: pointer;
            border: none;
            border-radius: 50%; 
            background-color: #e0e0e0; 
            background-image: linear-gradient(to bottom, #f5f5f5, #e0e0e0); 
            box-shadow: 0px 5px 15px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, color 0.3s ease, text-shadow 0.3s ease, background-image 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; 
            color: #555555; 
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(255,255,255,0.7); 
        }

        #startStopButton.active-state {
            background-color: #4CAF50; 
            background-image: linear-gradient(to bottom, #66bb6a, #4CAF50); 
            color: white; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4); 
        }

        /* Task Management UI Styles */
        #taskDisplay {
            color: #757575; 
            font-style: italic;
            padding: 5px 0;
            cursor: pointer; 
            transition: color 0.3s ease;
            text-align: center; /* Ensure it's centered */
        }

        #taskDisplay:hover {
            color: #333; 
        }

        #taskSelectionPanel {
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 15px;
            margin-top: 5px; 
            opacity: 0; 
            max-height: 0; 
            overflow: hidden; 
            transition: opacity 0.3s ease, max-height 0.3s ease, visibility 0.3s ease; 
            width: 250px; /* Give panel a defined width */
            box-sizing: border-box;
        }

        .presetTaskItem {
            padding: 8px 5px; 
            cursor: pointer; 
            border-bottom: 1px solid #eee; 
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .presetTaskItem:last-child { 
            border-bottom: none;
        }

        .presetTaskItem:hover {
            background-color: #f0f0f0;
        }

        .presetTaskItem .presetTaskName {
            flex-grow: 1;
        }
        .presetTaskItem .editPresetInput { /* Phase 2 */
            flex-grow: 1;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }


        .edit-icon {
            margin-left: 10px; 
            cursor: pointer; 
            font-size: 0.9em;
        }

        #customTaskInput {
            width: 100%; /* Let padding be handled by box-sizing */
            padding: 8px 5px; 
            margin-top: 10px; 
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box; 
        }
        
        #customTaskInput::placeholder {
            font-style: italic;
            color: #999;
        }

        #presetTaskTimeDisplay {
            font-size: 1.5rem;
            color: #4CAF50; 
            margin-top: 5px; 
            text-align: center;
        }
    </style>
</head>
<body onbeforeunload="handlePageClose()">
    <button id="startStopButton" onclick="handleStartStopClick()"></button> 
    <div id="sessionTimeDisplay">00:00:00</div>
    <div id="totalTimeDisplay">00:00:00</div>
    <div id="taskContainer">
        <div id="taskDisplay">I'm working on...</div>
        <div id="taskSelectionPanel"> 
            {/* Preset tasks will be rendered here by JS */}
            <input type="text" id="customTaskInput" placeholder="Or enter custom task (max 30 chars)" maxlength="30"> 
        </div>
    </div>
    <div id="presetTaskTimeDisplay">00:00:00</div>

    <script>
        // Main Timer DOM Elements
        const totalTimeDisplayEl = document.getElementById('totalTimeDisplay'); 
        const sessionTimeDisplayEl = document.getElementById('sessionTimeDisplay'); 
        const startStopButton = document.getElementById('startStopButton');

        // Task UI DOM Elements
        const taskDisplayEl = document.getElementById('taskDisplay');
        const taskSelectionPanelEl = document.getElementById('taskSelectionPanel');
        const customTaskInputEl = document.getElementById('customTaskInput');
        const presetTaskTimeDisplayEl = document.getElementById('presetTaskTimeDisplay');

        // Main Timer State Variables
        let totalTimeToday = +localStorage.getItem('totalTimeToday') || 0;
        let lastActiveDate = localStorage.getItem('lastActiveDate') || getCurrentDateString();
        let isTimerRunning = localStorage.getItem('isTimerRunning') === 'true';
        let timerStartTime = +localStorage.getItem('timerStartTime') || null;
        let timerInterval;
        
        // Task State Variables
        let currentTaskName = localStorage.getItem('currentTaskName') || "I'm working on...";
        let currentSelectedTaskId = localStorage.getItem('currentSelectedTaskId') || null;
        let presetTasks = JSON.parse(localStorage.getItem('presetTasks')) || [
            {id: 'p1', name: 'Work'}, {id: 'p2', name: 'Study'}, {id: 'p3', name: 'Exercise'}
        ];
        // Phase 3 State
        let dailyPresetTaskTotals = JSON.parse(localStorage.getItem('dailyPresetTaskTotals')) || {};
        let activeTaskStartTime = localStorage.getItem('activeTaskStartTime') ? parseInt(localStorage.getItem('activeTaskStartTime')) : null;
        
        // Phase 4 State
        let sessionLogs = JSON.parse(localStorage.getItem('sessionLogs')) || [];


        function getCurrentDateString() { return new Date().toISOString().slice(0, 10); }
        function formatTime(s) { let h=Math.floor(s/3600), m=Math.floor((s%3600)/60); s%=60; return (h<10?'0':'')+h+':'+(m<10?'0':'')+m+':'+(s<10?'0':'')+s; }
        
        function updateDisplays() { 
            let currentMainSessionSeconds = 0;
            if (isTimerRunning && timerStartTime) {
                currentMainSessionSeconds = Math.floor((Date.now() - timerStartTime) / 1000);
            }
            sessionTimeDisplayEl.textContent = formatTime(currentMainSessionSeconds);
            totalTimeDisplayEl.textContent = formatTime(totalTimeToday + currentMainSessionSeconds);
            
            startStopButton.textContent = isTimerRunning ? 'ON' : 'OFF';
            
            // Phase 3: Update presetTaskTimeDisplayEl
            if (currentSelectedTaskId && currentSelectedTaskId.startsWith('p')) {
                let currentPresetTotal = dailyPresetTaskTotals[currentSelectedTaskId] || 0;
                if (isTimerRunning && activeTaskStartTime && currentSelectedTaskId === currentSelectedTaskId) { // ensure this task is the one running
                    currentPresetTotal += Math.floor((Date.now() - activeTaskStartTime) / 1000);
                }
                presetTaskTimeDisplayEl.textContent = formatTime(currentPresetTotal);
                presetTaskTimeDisplayEl.style.display = 'block';
            } else {
                presetTaskTimeDisplayEl.style.display = 'none';
            }
        }

        function saveState() {
            localStorage.setItem('totalTimeToday', totalTimeToday);
            localStorage.setItem('lastActiveDate', lastActiveDate);
            localStorage.setItem('isTimerRunning', isTimerRunning);
            localStorage.setItem('timerStartTime', timerStartTime);
            
            localStorage.setItem('currentTaskName', currentTaskName);
            localStorage.setItem('currentSelectedTaskId', currentSelectedTaskId);
            localStorage.setItem('presetTasks', JSON.stringify(presetTasks));
            
            localStorage.setItem('dailyPresetTaskTotals', JSON.stringify(dailyPresetTaskTotals)); // Phase 3
            localStorage.setItem('activeTaskStartTime', activeTaskStartTime); // Phase 3

            localStorage.setItem('sessionLogs', JSON.stringify(sessionLogs)); // Phase 4
        }

        function startTimer() {
            isTimerRunning = true; 
            if (!timerStartTime) timerStartTime = Date.now(); 
            
            if (currentSelectedTaskId && !activeTaskStartTime) { // Phase 3: If a task is selected, ensure activeTaskStartTime is set
                activeTaskStartTime = Date.now(); 
            }

            startStopButton.classList.add('active-state');
            document.body.classList.add('timer-active'); // Phase 5
            if(timerInterval) clearInterval(timerInterval); 
            timerInterval = setInterval(updateDisplays, 1000); 
            updateDisplays(); 
            saveState();
        }

        function stopTimer() {
            if (!isTimerRunning) return;
            
            const mainSessionEndTime = Date.now();
            const mainSessionDuration = timerStartTime ? Math.floor((mainSessionEndTime - timerStartTime) / 1000) : 0;
            totalTimeToday += mainSessionDuration;

            // Phase 3: Log time for active preset task
            if (currentSelectedTaskId && currentSelectedTaskId.startsWith('p') && activeTaskStartTime) {
                let taskSegmentDuration = Math.floor((mainSessionEndTime - activeTaskStartTime) / 1000);
                dailyPresetTaskTotals[currentSelectedTaskId] = (dailyPresetTaskTotals[currentSelectedTaskId] || 0) + taskSegmentDuration;
            }
            activeTaskStartTime = null; // Phase 3: Reset active task start time

            // Phase 4: Session Logging
            if (currentTaskName !== "I'm working on..." && mainSessionDuration > 0) {
                const logEntry = { 
                    startTime: timerStartTime, 
                    endTime: mainSessionEndTime, 
                    duration: mainSessionDuration, 
                    date: getCurrentDateString(), 
                    task: currentTaskName 
                };
                sessionLogs.push(logEntry);
            }
            
            isTimerRunning = false; 
            // timerStartTime = null; // Important: Keep timerStartTime to correctly reflect the segment just logged.
                                    // It will be reset by handleStartStopClick if a new segment starts.

            startStopButton.classList.remove('active-state');
            document.body.classList.remove('timer-active'); // Phase 5
            if(timerInterval) clearInterval(timerInterval); 
            timerInterval = null;
            updateDisplays(); // Update displays after all calculations
            saveState(); 
        }

        function handleStartStopClick() { 
            if (isTimerRunning) {
                stopTimer();
            } else {
                // Starting a new session segment
                timerStartTime = Date.now(); 
                if (currentSelectedTaskId) { // If a task is selected, its active time starts now
                    activeTaskStartTime = Date.now();
                }
                startTimer();
            }
        }
        function handlePageClose() { if (isTimerRunning) stopTimer(); }

        // --- Task Specific Functions ---
        function toggleTaskPanel(show) {
            if (show) {
                taskSelectionPanelEl.style.display = 'block';
                setTimeout(() => { 
                    taskSelectionPanelEl.style.opacity = '1';
                    taskSelectionPanelEl.style.maxHeight = '300px'; 
                }, 10); 
            } else {
                taskSelectionPanelEl.style.opacity = '0';
                taskSelectionPanelEl.style.maxHeight = '0';
                setTimeout(() => { 
                    if (taskSelectionPanelEl.style.opacity === '0') { 
                        taskSelectionPanelEl.style.display = 'none';
                    }
                }, 300); 
            }
        }

        function renderPresetTasks() { // Phase 2: Modified for editing
            const panel = taskSelectionPanelEl;
            panel.querySelectorAll('.presetTaskItem').forEach(item => item.remove());

            presetTasks.forEach(task => {
                const item = document.createElement('div');
                item.className = 'presetTaskItem';
                item.dataset.taskId = task.id;

                const nameSpan = document.createElement('span');
                nameSpan.className = 'presetTaskName';
                nameSpan.textContent = task.name;
                item.appendChild(nameSpan);

                const editSpan = document.createElement('span');
                editSpan.className = 'edit-icon';
                editSpan.innerHTML = '✏️'; 
                item.appendChild(editSpan);
                
                panel.insertBefore(item, customTaskInputEl); // Insert before custom input

                nameSpan.addEventListener('click', () => selectTask(task.id, task.name, true)); // Click name to select
                
                editSpan.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent selectTask from firing
                    const currentName = nameSpan.textContent;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'editPresetInput';
                    input.value = currentName;
                    
                    item.replaceChild(input, nameSpan);
                    input.focus();

                    const saveEdit = () => {
                        const newName = input.value.trim() || currentName; // Revert if empty
                        const taskToUpdate = presetTasks.find(p => p.id === task.id);
                        if (taskToUpdate) {
                            taskToUpdate.name = newName;
                        }
                        saveState();
                        renderPresetTasks(); // Re-render all to update UI (simpler)
                        if (currentSelectedTaskId === task.id) { // Update main display if current task was edited
                            currentTaskName = newName;
                            taskDisplayEl.textContent = newName;
                        }
                    };
                    input.addEventListener('blur', saveEdit);
                    input.addEventListener('keypress', (ev) => { if (ev.key === 'Enter') input.blur(); });
                });
            });
        }
        
        function selectTask(id, name, isPreset) { // Phase 3: Modified
            // Log time for the PREVIOUSLY active preset task segment before switching
            if (currentSelectedTaskId && currentSelectedTaskId.startsWith('p') && activeTaskStartTime) {
                let previousTaskSegmentDuration = Math.floor((Date.now() - activeTaskStartTime) / 1000);
                dailyPresetTaskTotals[currentSelectedTaskId] = (dailyPresetTaskTotals[currentSelectedTaskId] || 0) + previousTaskSegmentDuration;
            }

            currentTaskName = name;
            currentSelectedTaskId = id; 
            activeTaskStartTime = Date.now(); // New task's segment starts now

            taskDisplayEl.textContent = currentTaskName;
            taskDisplayEl.style.fontStyle = 'normal'; 
            taskDisplayEl.style.color = '#333';
            toggleTaskPanel(false);
            
            // Reset main session display *if the main timer is not running*.
            if (!isTimerRunning) {
                sessionTimeDisplayEl.textContent = formatTime(0);
            }
            // If timer IS running, main session display continues. The activeTaskStartTime handles the new task's timing.
            
            updateDisplays(); // Update to show correct preset time (will be 0 for new live segment)
            saveState(); 
        }

        function initTasks() {
            taskDisplayEl.textContent = currentTaskName;
            if (currentTaskName !== "I'm working on...") {
                 taskDisplayEl.style.fontStyle = 'normal';
                 taskDisplayEl.style.color = '#333';
            }
            renderPresetTasks(); 
            updateDisplays(); // Ensure presetTaskTimeDisplay is updated on load

            taskDisplayEl.addEventListener('click', () => {
                const isPanelVisible = taskSelectionPanelEl.style.opacity === '1';
                toggleTaskPanel(!isPanelVisible);
            });

            customTaskInputEl.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && customTaskInputEl.value.trim() !== '') {
                    if (customTaskInputEl.value.trim().length > 30) {
                        alert('Task name too long (max 30 chars).'); return;
                    }
                    selectTask('custom:' + Date.now(), customTaskInputEl.value.trim(), false); // Use timestamp for custom ID
                    customTaskInputEl.value = '';
                }
            });
        }

        // --- Main Initialization Sequence ---
        initTasks(); 

        if (getCurrentDateString() !== lastActiveDate) { // Daily Reset
            totalTimeToday = 0; 
            lastActiveDate = getCurrentDateString();
            dailyPresetTaskTotals = {}; // Phase 3
            activeTaskStartTime = null; // Phase 3
            // sessionLogs are kept across days. Could add date filtering later if needed.
            
            if(isTimerRunning){ 
                isTimerRunning=false; 
                // No need to call document.body.classList.remove('timer-active'); here, it's handled below
            }
            timerStartTime = null; 
        }

        if (isTimerRunning) { // Phase 5: UI Enhancement for body class
            document.body.classList.add('timer-active');
            // timerStartTime is loaded from localStorage.
            // If a task was active, activeTaskStartTime should also be loaded and used.
            // Ensure activeTaskStartTime is set if timer is running and a task is selected.
            if (currentSelectedTaskId && !activeTaskStartTime) {
                 activeTaskStartTime = timerStartTime; // Align if it was somehow lost but task was active
            }
            startStopButton.classList.add('active-state');
            if(timerInterval) clearInterval(timerInterval); 
            timerInterval = setInterval(updateDisplays, 1000); 
        } else {
            document.body.classList.remove('timer-active'); // Phase 5
            startStopButton.classList.remove('active-state');
        }

        updateDisplays(); 
        saveState();
    </script>
</body>
</html>
